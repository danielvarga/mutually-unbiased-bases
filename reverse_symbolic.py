# here we fixed on the graph structure of mub_120_normal.npy,
# already reverse engineered it with reverse.py
# and now we would like to get analytical formulas for its coefficients.

import numpy as np
from numpy import array


# the following code block was generated by
# python reverse.py mub_120_normal.npy
# (the part after "OR TO SUMMARIZE IT:")

ayes = array([[-2.751366690132465  ,  0.23302442072099624, -0.28177169442180117,
         3.140550341542713  ],
       [-2.2061861924851285 , -1.3161790222277756 ,  2.4862419239973748 ,
         1.719653853418465  ],
       [-1.2021632471836936 ,  0.36133137554552014,  1.8126122461743086 ,
        -2.3838841006815334 ]])
bs = array([[-1.7043002024899867 , -2.9938316453522766 , -0.3670351069052802 ,
         1.0460241755953985 ],
       [ 1.020538810034026  , -2.363507636978492  , -1.7026793443431356 ,
         1.8047862023478254 ],
       [-0.24022910847057477,  1.3233965778127565 , -0.36691520514824766,
         1.7196426916213783 ]])
cs = array([-0.06494462922858202, -0.8553972072220128 , -2.0309128750402206 ])
graphs = array([[[ 0,  0,  0,  0,  0,  0],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  0,  0,  0,  0,  0]],

       [[ 0,  0,  0,  0,  0,  0],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  0,  0,  0,  0,  0]],

       [[ 0,  0,  0,  0,  0,  0],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  0,  0,  0,  0,  0]]])


xs = np.exp(1j * ayes)
ys = np.exp(1j * bs)
zs = np.exp(1j * cs)

TP = 2 * np.pi
TIP = 2j * np.pi
W = np.exp(TIP / 3)


def rebuild(xs, ys, zs, graphs):
    a = W ** graphs
    a[:, 1:5, :3] *= xs[..., None]
    a[:, 1:5, 3:] *= ys[..., None]
    a[:, 5, :3] *= zs[..., None]
    a[:, 5, 3:] *= - zs[..., None]
    b0 = np.eye(6, dtype=np.complex128) * 6 ** 0.5
    b0 = b0[[0, 1, 2, 4, 5, 3], :] # that's the zrow permutation
    a = np.concatenate([b0[None, ...], a])
    return a


np.set_printoptions(precision=5, suppress=True)

a = rebuild(xs, ys, zs, graphs)

def verify(a, verbose=False):
    m, n = 4, 6
    for i in range(m):
        closeness = np.abs(6 * np.eye(6) - np.conjugate(a[i].T) @ a[i])
        if verbose:
            print(i, i)
            print(closeness)
        assert np.allclose(closeness, 0, atol=1e-5)

    for i in range(m):
        for j in range(i + 1, m):
            aprod = np.abs(np.conjugate(a[i].T) @ a[j]) / 6
            distinct = tuple(np.unique((aprod * 1000).astype(int)))
            assert distinct == (355, 385, 425) or distinct == (408, )
            if verbose:
                print(i, j)
                print(aprod)

verify(a, verbose=False)


# this works but don't know how to finish it, abandoned for now:
'''
from sympy import Matrix, sqrt, I

W_s = -1 / 2 + sqrt(3) * I / 2
W2_s = -1 / 2 - sqrt(3) * I / 2

def graph_to_symbol(g):
    mp = {0: 1, 1: W_s, -1: W2_s}
    mapped = [[mp[g[i, j]] for j in range(6)] for i in range(6)]
    mapped = Matrix(mapped)
    for i in range(3, 6):
        mapped[5, i] = -1
    return mapped
'''

# (B_i^dag B_j)_kl = 
def rule(i, j, k, l):
    aprod = np.abs(np.conjugate(a[i].T) @ a[j]) / 6
    