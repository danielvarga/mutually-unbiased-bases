# here we fixed on the graph structure of mub_120_verynormal.npy,
# already reverse engineered it with reverse.py from mub_120_normal.npy,
# and now we would like to get analytical formulas for its coefficients.

import numpy as np
from numpy import array


# the following code block succintly describes mub_120_verynormal.npy.
# it was generated by
# python reverse.py mub_120_normal.npy  mub_120_verynormal.npy
# (the part after "OR TO SUMMARIZE IT:")
#
# as the assert will show, rebuild reconstructs mub_120_verynormal.npy from it.
# however, note the zrow permutation of the B_0 basis, it's easy to forget about it.

ayes = array([[-2.751366690132465  ,  0.23302442072099624, -0.28177169442180117,
         3.140550341542713  ],
       [-2.2061861924851285 , -1.3161790222277756 ,  2.4862419239973748 ,
         1.719653853418465  ],
       [-1.2021632471836936 ,  0.36133137554552014,  1.8126122461743086 ,
        -2.3838841006815334 ]])
bs = array([[-1.7043002024899867 , -2.9938316453522766 , -0.3670351069052802 ,
         1.0460241755953985 ],
       [ 1.020538810034026  , -2.363507636978492  , -1.7026793443431356 ,
         1.8047862023478254 ],
       [-0.24022910847057477,  1.3233965778127565 , -0.36691520514824766,
         1.7196426916213783 ]])
cs = array([-0.06494462922858202, -0.8553972072220128 , -2.0309128750402206 ])
graphs = array([[[ 0,  0,  0,  0,  0,  0],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  0,  0,  0,  0,  0]],

       [[ 0,  0,  0,  0,  0,  0],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  0,  0,  0,  0,  0]],

       [[ 0,  0,  0,  0,  0,  0],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0,  1, -1,  0,  1, -1],
        [ 0, -1,  1,  0, -1,  1],
        [ 0,  0,  0,  0,  0,  0]]])


xs = np.exp(1j * ayes)
ys = np.exp(1j * bs)
zs = np.exp(1j * cs)

TP = 2 * np.pi
TIP = 2j * np.pi
Wnumeric = np.exp(TIP / 3)


def rebuild(xs, ys, zs, graphs):
    a = Wnumeric ** graphs
    a[:, 1:5, :3] *= xs[..., None]
    a[:, 1:5, 3:] *= ys[..., None]
    a[:, 5, :3] *= zs[..., None]
    a[:, 5, 3:] *= - zs[..., None]
    b0 = np.eye(6, dtype=np.complex128) * 6 ** 0.5
    # that's the zrow permutation applied to the B_0 standard basis.
    # unfortunately we have to hardwire it.
    b0 = b0[[0, 1, 2, 4, 5, 3], :]
    a = np.concatenate([b0[None, ...], a])
    return a


np.set_printoptions(precision=5, suppress=True)

a = rebuild(xs, ys, zs, graphs) / 6 ** 0.5
a_supposed = np.load("mub_120_verynormal.npy")
assert np.allclose(a, a_supposed, atol=1e-10)


import sympy
from sympy import symbols, MatrixSymbol, Matrix, eye, ones, conjugate, sqrt
from sympy import expand, factor, simplify, collect, solveset, solve, Eq
from sympy.physics.quantum.dagger import Dagger
from sympy.matrices.dense import matrix_multiply_elementwise

def varset(v, m):
    return f"{v}0:3(0:{m})"

Xvars = symbols(varset("X", 4))
Yvars = symbols(varset("Y", 4))
Zvars = symbols(varset("Z", 1))
X = Matrix(3, 4, Xvars)
Y = Matrix(3, 4, Yvars)

# okay, but Y_i2 and Y_i3 can be calculated from the rest:
# Y[0,0]*conjugate(X[0,0]) + Y[0,3]*conjugate(X[0,3]) == 0
# -> Y[0,3] = -Y[0,0]*conjugate(X[0,0])*X[0,3]
# ...so we enforce this:
for i in range(3):
    Y[i, 3] = - Y[i, 0] * conjugate(X[i, 0]) * X[i, 3]
    Y[i, 2] = - Y[i, 1] * conjugate(X[i, 1]) * X[i, 2]

Z = Matrix(3, 1, Zvars)
Wsym = symbols('W')


# note: at this point, Y[i, 2] and Y[i, 3] are not free variables anymore.
def rebuild_symbolic(graphs, i):
    graph = graphs[i]
    m = ones(6, 6)
    for k in range(6):
        for l in range(6):
            if graph[k, l] == 1:
                m[k, l] *= Wsym
            elif graph[k, l] == -1:
                m[k, l] *= Wsym * Wsym
    for k in range(1, 5):
        for l in range(3):
            m[k, l] *= X[i, k - 1] # note the potential one off error!
            m[k, l + 3] *= Y[i, k - 1]
    for l in range(6):
        m[5, l] *= Z[i]
    for l in range(3, 6):
        m[5, l] *= -1
    return m


def simplify_roots(expr):
    e = expr.subs(conjugate(Wsym), Wsym ** 2)
    e = e.subs(Wsym ** 3, 1).subs(Wsym ** 4, Wsym).subs(Wsym ** 5, Wsym ** 2).subs(Wsym ** 6, 1)
    return e


def apply_elemwise(fn, matrix):
    m = matrix.as_mutable()
    for k in range(m.shape[0]):
        for l in range(m.shape[1]):
            m[k, l] = fn(m[k, l])
    return m


def enforce_norm_one(p):
    for var in Xvars + Yvars + Zvars:
        p = p.subs(conjugate(var) * var, 1)
    return p


m0 = rebuild_symbolic(graphs, 0)
m1 = rebuild_symbolic(graphs, 1)
m2 = rebuild_symbolic(graphs, 2)
print("symbolic formula for B_1 :")
print(m0)
prod01 = Dagger(m0) * m1
prod01 = simplify_roots(prod01)

print("symbolic formula for B_1^* B_2 :")
print(prod01)
exit()


a = rebuild(xs, ys, zs, graphs)
prod01numeric = np.conjugate(a[1]).T.dot(a[2]) / 6
print(np.abs(prod01numeric))
print(np.angle(prod01numeric))
print(prod01numeric[1, 0], prod01numeric[2, 1], prod01numeric[0, 2])
exit()












amplitude01 = expand(matrix_multiply_elementwise(Dagger(prod01), prod01))
amplitude01 = simplify_roots(amplitude01)
amplitude01 = enforce_norm_one(amplitude01)
print("---")
print("symbolic formula for abs^2(B_1^dag B_2) :")
print(amplitude01)

prod00 = Dagger(m0) * m0
prod00 = simplify_roots(prod00)
prod00 = enforce_norm_one(prod00)

# we don't need this, we rely on the simplify_roots (conjugate(Wsym) == Wsym ** 2, Wsym ** 3 == 1)
# and the 1 + Wsym + Wsym ** 2 == 0 substitutions:
#
# p = expand(p.subs(Wsym, -1/2 + sqrt(3)/2j))

prod00 = apply_elemwise(lambda expr: factor(expr).subs(1 + Wsym + Wsym ** 2, 0), prod00)

print("---")
print("symbolic formula for B_1^dag B_1 :")

# this is not needed anymore, because the rhombus constraints are built into the matrices.
# i keep the old code, though, because this change increases the degree of the polynomials.
'''
p = prod00
p = apply_elemwise(lambda expr: collect(expr, Wsym), p)
p = p.subs(Y[0,0]*conjugate(X[0,0]) + Y[0,3]*conjugate(X[0,3]), 0)
p = apply_elemwise(lambda expr: collect(expr, Wsym), p)
p = p.subs(Y[0,1]*conjugate(X[0,1]) + Y[0,2]*conjugate(X[0,2]), 0)
p = apply_elemwise(lambda expr: collect(expr, Wsym), p)
# these two subs are redundant, but sympy does not spot that:
p = p.subs(X[0,0]*conjugate(Y[0,0]) + X[0,3]*conjugate(Y[0,3]), 0)
p = apply_elemwise(lambda expr: collect(expr, Wsym), p)
p = p.subs(X[0,1]*conjugate(Y[0,1]) + X[0,2]*conjugate(Y[0,2]), 0)
'''

print(prod00)


np.set_printoptions(precision=5, suppress=True)

a = rebuild(xs, ys, zs, graphs)

def verify(a, verbose=False):
    m, n = 4, 6
    for i in range(m):
        closeness = np.abs(6 * np.eye(6) - np.conjugate(a[i].T) @ a[i])
        if verbose:
            print(i, i)
            print(closeness)
        assert np.allclose(closeness, 0, atol=1e-5)

    for i in range(m):
        for j in range(i + 1, m):
            aprod = np.abs(np.conjugate(a[i].T) @ a[j]) / 6
            distinct = tuple(np.unique((aprod * 1000).astype(int)))
            assert distinct == (355, 385, 425) or distinct == (408, )
            if verbose:
                print(i, j)
                print(aprod)

verify(a, verbose=False)


# this works but don't know how to finish it, abandoned for now:
'''
from sympy import Matrix, sqrt, I

W_s = -1 / 2 + sqrt(3) * I / 2
W2_s = -1 / 2 - sqrt(3) * I / 2

def graph_to_symbol(g):
    mp = {0: 1, 1: W_s, -1: W2_s}
    mapped = [[mp[g[i, j]] for j in range(6)] for i in range(6)]
    mapped = Matrix(mapped)
    for i in range(3, 6):
        mapped[5, i] = -1
    return mapped
'''


# (B_i^dag B_j)_kl = 
def prod_elem(i, j, k, l):
    aprod = np.conjugate(a[i].T) @ a[j]
    return aprod[k, l]


for i in range(1, 4):
    for j in range(i + 1, 4):
        for k in range(6):
            for l in range(6):
                p = prod_elem(i, j, k, l)
                rounded = (np.abs(p / 6) * 1000).astype(int)
                assert rounded in (355, 385, 425)
